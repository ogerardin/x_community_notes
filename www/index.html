<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>X/Twitter Community Notes</title>
    <link rel="stylesheet" href="/styles.css?v=14">
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script>
        document.addEventListener('alpine:init', () => {
            Alpine.data('tabs', () => ({
                setTab(tab) {
                    this.activeTab = tab;
                    window.location.hash = tab;
                }
            }));

            Alpine.data('app', () => ({
                activeTab: window.location.hash?.slice(1) || 'search',
                noteCount: 0,
                latestTimestamp: null,
                importStatus: null,
                importHistory: [],
                importError: '',
                backendOnline: true,
                importPollInterval: null,
                schedulerStatus: null,
                setTab(tab) {
                    this.activeTab = tab;
                    window.location.hash = tab;
                },
                async refreshNoteStats() {
                    if (['downloading', 'importing', 'indexing'].includes(this.importStatus?.status)) return;
                    try {
                        let resp = await fetch('/api/note?select=summary.count()');
                        let data = await resp.json();
                        this.noteCount = data[0]?.count ?? 0;
                        resp = await fetch('/api/note?select=createdatmillis.max()');
                        data = await resp.json();
                        this.latestTimestamp = data[0]?.max ?? 0;
                    } catch (e) {}
                },
                async fetchImportStatus() {
                    try {
                        let resp = await fetch('/api/imports/current');
                        if (!resp.ok) throw new Error('Failed to fetch import status');
                        let data = await resp.json();
                        this.importStatus = Array.isArray(data) ? (data[0] ?? null) : data;
                        this.importError = '';
                        this.backendOnline = true;
                        await this.fetchImportHistory();
                        const active = ['importing', 'downloading', 'indexing'].includes(this.importStatus?.status);
                        if (active) this.startPolling(); else this.stopPolling();
                    } catch (e) {
                        this.backendOnline = false;
                        this.importError = '';
                    }
                },
                async fetchImportHistory() {
                    try {
                        let resp = await fetch('/api/imports');
                        if (!resp.ok) throw new Error('Failed to fetch import history');
                        this.importHistory = await resp.json() || [];
                    } catch (e) {}
                },
                async fetchSchedulerStatus() {
                    try {
                        let resp = await fetch('/api/imports/scheduler');
                        if (resp.ok) this.schedulerStatus = await resp.json();
                    } catch (e) {}
                },
                startPolling() {
                    if (this.importPollInterval) return;
                    this.importPollInterval = setInterval(() => this.fetchImportStatus(), 5000);
                },
                stopPolling() {
                    if (this.importPollInterval) {
                        clearInterval(this.importPollInterval);
                        this.importPollInterval = null;
                    }
                },
                statusBadgeClass(status) {
                    switch(status) {
                        case 'completed': return 'badge-success';
                        case 'failed': return 'badge-error';
                        case 'importing':
                        case 'downloading':
                        case 'indexing': return 'badge-info';
                        default: return 'badge-warning';
                    }
                },
                formatDuration(seconds) {
                    if (seconds === null || seconds === undefined) return '';
                    const m = Math.floor(seconds / 60);
                    const s = seconds % 60;
                    return m > 0 ? (s > 0 ? m + 'm ' + s + 's' : m + 'm') : s + 's';
                },
                formatFileSize(bytes) {
                    if (bytes === null || bytes === undefined) return '';
                    if (bytes >= 1e9) return (bytes / 1e9).toFixed(1) + ' GB';
                    if (bytes >= 1e6) return Math.round(bytes / 1e6) + ' MB';
                    return Math.round(bytes / 1e3) + ' KB';
                },
                formatRemainingTime(nextRun) {
                    if (!nextRun) return '-';
                    const now = new Date();
                    const next = new Date(nextRun);
                    const diffMs = next - now;
                    if (diffMs <= 0) return 'now';
                    const mins = Math.floor(diffMs / 60000);
                    if (mins < 60) return 'in ' + mins + 'm';
                    const hours = Math.floor(mins / 60);
                    const remainingMins = mins % 60;
                    return 'in ' + (remainingMins > 0 ? hours + 'h ' + remainingMins + 'm' : hours + 'h');
                },
                async triggerImport() {
                    try {
                        this.importError = '';
                        if (['importing', 'downloading', 'indexing'].includes(this.importStatus?.status)) {
                            this.importError = 'Update already in progress';
                            return;
                        }
                        let resp = await fetch('/api/imports/create', { method: 'POST' });
                        if (!resp.ok) throw new Error('Failed to trigger update: ' + resp.status);
                        await this.fetchImportStatus();
                    } catch (e) {
                        this.importError = e.message;
                    }
                },
                async abortImport() {
                    try {
                        if (!this.importStatus?.job_id) return;
                        let resp = await fetch('/api/imports/' + this.importStatus.job_id, { method: 'DELETE' });
                        if (!resp.ok) throw new Error('Failed to abort update');
                        await this.fetchImportStatus();
                    } catch (e) {
                        this.importError = e.message;
                    }
                },
                init() {
                    this.refreshNoteStats();
                    this.fetchImportStatus();
                    this.fetchSchedulerStatus();
                    setInterval(() => this.refreshNoteStats(), 30000);
                    setInterval(() => this.fetchSchedulerStatus(), 60000);
                    window.addEventListener('hashchange', () => {
                        this.activeTab = window.location.hash?.slice(1) || 'search';
                    });
                },
            }));

            Alpine.data('searchTab', () => ({
                loading: false,
                search: '',
                items: [],
                error: '',
                offset: 0,
                hasMore: true,
                totalCount: 0,
                async fetchItems(append = false) {
                    if (!append) {
                        this.items = [];
                        this.offset = 0;
                        this.hasMore = true;
                    }
                    if (!this.hasMore || this.loading) return;

                    this.loading = true;
                    this.error = '';
                    try {
                        const response = await fetch('/api/note?limit=50&offset=' + this.offset + '&summary_ts=wfts.' + encodeURIComponent(this.search) + '&select=createdatmillis,noteid,tweetid,noteauthorparticipantid,summary&order=createdatmillis.desc', {
                            headers: { 'Prefer': 'count=exact' }
                        });
                        if (!response.ok) throw new Error('Fetch failed with status ' + response.status);

                        this.totalCount = parseInt(response.headers.get('Content-Range')?.split('/')[1] || '0');
                        const data = await response.json();

                        if (append) {
                            this.items = [...this.items, ...data];
                        } else {
                            this.items = data;
                        }

                        this.hasMore = data.length === 50;
                        this.offset += data.length;
                    } catch (e) {
                        this.error = 'Failed to load notes: ' + e.message;
                    } finally {
                        this.loading = false;
                    }
                },
                setupInfiniteScroll() {
                    const observer = new IntersectionObserver(entries => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) this.fetchItems(true);
                        });
                    }, { rootMargin: '100px' });

                    this.$watch('items', () => {
                        if (this.hasMore) {
                            const sentinel = this.$el.querySelector('.scroll-sentinel');
                            if (sentinel) observer.observe(sentinel);
                        }
                    });
                },
                init() {
                    this.setupInfiniteScroll();
                },
                formatSummary(summary) {
                    if (!summary) return '';
                    let html = summary.replace(/(https?:\/\/[^\s]+)/g, url => '<a href="' + url + '" target="_blank" rel="noopener">' + url + '</a>');
                    return html.replace(/  /g, '<br>');
                },
                hashColor(str) {
                    let hash = 0;
                    for (let i = 0; i < str.length; i++) hash = str.charCodeAt(i) + ((hash << 5) - hash);
                    return 'hsl(' + (Math.abs(hash) % 360) + ', 60%, 45%)';
                },
            }));

            Alpine.data('adminTab', () => ({}));
        });
    </script>
</head>
<body x-data="app()">
<header class="header">
    <div class="header-content">
        <div class="header-title">
            <h1>X/Twitter Searchable Community Notes Database</h1>
            <span class="header-stats" x-show="['importing','downloading','indexing'].includes(importStatus?.status)" x-cloak style="color: var(--accent);">
                <svg class="spinner" style="width: 14px; height: 14px; vertical-align: middle; margin-right: 4px;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="3" fill="none" stroke-dasharray="31.4 31.4"/></svg>
                <span x-text="importStatus?.status"></span> (<span x-text="importStatus?.status === 'downloading' ? (importStatus?.download_percentage ?? 0) + '%' : importStatus?.status === 'indexing' ? (importStatus?.index_blocks_total ? Math.round((importStatus?.index_blocks_done ?? 0) / importStatus.index_blocks_total * 100) + '%' : '...') : ((importStatus?.rows_processed ?? 0).toLocaleString() + ' / ' + (importStatus?.total_rows ?? '?'))"></span>)
            </span>
            <span class="header-stats" x-show="!['importing','downloading','indexing'].includes(importStatus?.status)" x-cloak>(<span x-text="noteCount.toLocaleString()"></span> notes<template x-if="latestTimestamp">, Latest: <span x-text="new Date(latestTimestamp).toLocaleDateString()"></span></template>)</span>
        </div>
        <nav class="tabs">
            <button 
                class="tab" 
                :class="{ 'active': activeTab === 'search' }"
                @click="setTab('search')"
            >Search</button>
            <button 
                class="tab" 
                :class="{ 'active': activeTab === 'admin' }"
                @click="setTab('admin')"
            >Admin</button>
        </nav>
    </div>
</header>

<main class="container">

    <!-- SEARCH TAB -->
    <div x-show="activeTab === 'search'" x-data="searchTab()">

        <template x-if="loading">
            <div class="loading-overlay">
                <div class="spinner"></div>
                <span>Loading...</span>
            </div>
        </template>

        <div class="search-section">
            <div class="search-wrapper">
                <div class="search-input-group">
                    <svg class="search-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"></circle>
                        <path d="m21 21-4.35-4.35"></path>
                    </svg>
                    <input class="search-input" x-model="search" type="search" placeholder="Search notes..." @keyup.enter="fetchItems()" x-init="$el.focus()">
                    <button class="search-clear" @click="search = ''; fetchItems();" x-show="search" title="Clear search">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M18 6 6 18M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                <button class="btn btn-primary" @click="fetchItems()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"></circle>
                        <path d="m21 21-4.35-4.35"></path>
                    </svg>
                    Search
                </button>
            </div>
        </div>

        <div class="error-msg" x-show="error" x-text="error"></div>
        <div class="results-info" x-show="!loading && !error && items.length > 0" x-text="'Found ' + totalCount.toLocaleString() + ' notes'"></div>
        
        <div class="empty-state" x-show="!loading && items.length === 0 && !error">
            <div class="empty-state-icon">ðŸ“­</div>
            <div>No results found</div>
        </div>

        <div class="notes-list" x-show="items.length > 0">
            <template x-for="item in items" :key="item.noteid">
                <article class="note-card">
                    <div class="note-header">
                        <div class="note-meta">
                            <span class="note-date" x-text="new Date(item.createdatmillis).toLocaleString()"></span>
                            <span class="author-badge" :style="'background: ' + hashColor(item.noteauthorparticipantid)" x-text="item.noteauthorparticipantid?.slice(-4) || ''"></span>
                        </div>
                        <div class="note-actions">
                            <button class="action-btn" @click="window.open('https://x.com/i/communitynotes/t/' + item.tweetid, '_blank', 'noopener')" title="View notes on tweet">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                                    <polyline points="15 3 21 3 21 9"></polyline>
                                    <line x1="10" y1="14" x2="21" y2="3"></line>
                                </svg>
                            </button>
                            <button class="action-btn" :class="{ 'copied': item._copied }" @click="navigator.clipboard.writeText(item.summary || ''); item._copied = true; setTimeout(() => item._copied = false, 1500)" title="Copy note text">
                                <svg x-show="!item._copied" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                                </svg>
                                <svg x-show="item._copied" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="20 6 9 17 4 12"></polyline>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="note-content" x-html="formatSummary(item.summary)"></div>
                </article>
            </template>
        </div>
        <div class="scroll-sentinel"></div>
    </div>

    <!-- ADMIN TAB -->
    <div x-show="activeTab === 'admin'">

        <div class="offline-banner" x-show="!backendOnline">Backend unavailable - Connection lost</div>

        <div class="stats-grid">
            <div class="stat-card">
                <span class="stat-label">Update Status</span>
                <span class="badge" :class="statusBadgeClass(importStatus?.status)" x-text="importStatus?.status || 'idle'"></span>
            </div>
            <div class="stat-card" x-show="schedulerStatus">
                <span class="stat-label">Last Import Data Date</span>
                <span x-text="schedulerStatus?.last_data_date || '-'"></span>
            </div>
            <div class="stat-card" x-show="schedulerStatus">
                <span class="stat-label">Auto-Update</span>
                <div style="display: flex; flex-direction: column; gap: 0.25rem;">
                    <div x-show="schedulerStatus?.enabled" style="color: var(--text-secondary);">
                        Every <span x-text="schedulerStatus?.interval || '1h'"></span>
                    </div>
                    <div x-show="schedulerStatus?.enabled" style="color: var(--text-secondary);">
                        Next: <span x-text="formatRemainingTime(schedulerStatus?.next_run)"></span>
                    </div>
                    <div x-show="!schedulerStatus?.enabled" style="color: var(--text-muted);">Disabled</div>
                </div>
            </div>
        </div>

        <div class="import-controls">
            <button class="btn btn-primary" @click="triggerImport()" x-bind:disabled="['importing','downloading','indexing'].includes(importStatus?.status)">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
                Update Notes
            </button>
            <button class="btn btn-danger" @click="abortImport()" x-show="importStatus?.status === 'importing' || importStatus?.status === 'downloading'" :disabled="importStatus?.status === 'indexing'">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="15" y1="9" x2="9" y2="15"></line>
                    <line x1="9" y1="9" x2="15" y2="15"></line>
                </svg>
                Abort
            </button>
        </div>

        <div class="error-msg" x-show="importError" x-text="importError"></div>

        <div class="card">
            <h2 style="margin-bottom: 1rem;">Update History</h2>
            <div class="table-wrapper">
                <table class="history-table">
                    <thead>
                        <tr>
                            <th>Started</th>
                            <th>Completed</th>
                            <th>Files</th>
                            <th>Download</th>
                            <th>Import</th>
                            <th>Indexing</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody x-show="importHistory.length > 0">
                        <template x-for="h in importHistory" :key="h.id">
                            <tr>
                                <td x-text="new Date(h.started_at).toLocaleString()"></td>
                                <td x-text="h.status === 'completed' && h.completed_at ? new Date(h.completed_at).toLocaleString() : '-'"></td>
                                <td>
                                    <template x-if="h.file_names">
                                        <div style="display: flex; flex-direction: column; gap: 0.25rem;">
                                            <template x-for="f in h.file_names.split(',')" :key="f">
                                                <span style="font-size: 0.8rem; color: var(--text-secondary);" x-text="f"></span>
                                            </template>
                                        </div>
                                    </template>
                                    <span x-show="!h.file_names" style="color: var(--text-muted);">-</span>
                                </td>
                                <td>
                                    <template x-if="h.status === 'downloading'">
                                        <span style="color: var(--accent);" x-text="(h.current_file_index ?? 0) + 1 + ' / ' + (h.total_files ?? 0) + ' â€” ' + (h.download_percentage ?? 0) + '%'"></span>
                                    </template>
                                    <template x-if="h.status !== 'downloading' && h.download_cached">
                                        <span style="color: var(--text-secondary);" x-text="(h.total_files ?? 0) + ' files, ' + formatFileSize(h.file_size) + ' (cached)'"></span>
                                    </template>
                                    <template x-if="h.status !== 'downloading' && !h.download_cached && h.download_duration !== null">
                                        <span style="color: var(--text-secondary);" x-text="(h.total_files ?? 0) + ' files, ' + formatFileSize(h.file_size) + ' in ' + formatDuration(h.download_duration) + (h.download_speed ? ' ' + h.download_speed : '')"></span>
                                    </template>
                                    <span x-show="h.status !== 'downloading' && !h.download_cached && h.download_duration === null" style="color: var(--text-muted);">-</span>
                                </td>
                                <td>
                                    <template x-if="h.status === 'importing'">
                                        <span style="color: var(--accent);" x-text="(h.rows_processed ?? 0).toLocaleString() + ' / ' + (h.total_rows ? h.total_rows.toLocaleString() : '?') + ' (' + (h.total_rows ? Math.round((h.rows_processed ?? 0) / h.total_rows * 100) : 0) + '%)'"></span>
                                    </template>
                                    <template x-if="h.status === 'completed' || h.status === 'indexing'">
                                        <span style="color: var(--text-secondary);" x-text="(h.total_rows ?? 0).toLocaleString() + ' rows in ' + formatDuration(h.import_duration)"></span>
                                    </template>
                                    <span x-show="h.status === 'idle' || h.status === 'failed' || h.status === 'downloading'" style="color: var(--text-muted);">-</span>
                                </td>
                                <td>
                                    <template x-if="h.status === 'indexing'">
                                        <div class="progress-bar-wrap">
                                            <span style="color: var(--accent); font-size: 0.75rem;" x-text="h.index_blocks_total ? Math.round((h.index_blocks_done ?? 0) / h.index_blocks_total * 100) + '% â€” ' + (h.index_phase ?? 'building indexes') : (h.index_phase ?? 'building indexes...')"></span>
                                            <div class="progress-bar">
                                                <div class="progress-bar-fill" :style="'width:' + (h.index_blocks_total ? Math.round((h.index_blocks_done ?? 0) / h.index_blocks_total * 100) : 100) + '%'"></div>
                                            </div>
                                        </div>
                                    </template>
                                    <template x-if="h.status === 'completed' && h.indexing_started_at">
                                        <span style="color: var(--text-secondary);" x-text="formatDuration(Math.round((new Date(h.completed_at) - new Date(h.indexing_started_at)) / 1000))"></span>
                                    </template>
                                    <span x-show="!h.indexing_started_at && h.status !== 'indexing'" style="color: var(--text-muted);">-</span>
                                </td>
                                <td>
                                    <span class="badge" :class="statusBadgeClass(h.status)" x-text="h.status"></span>
                                    <span x-show="h.error_message" style="color: var(--error); display: block; margin-top: 0.25rem; font-size: 0.75rem;" x-text="h.error_message"></span>
                                </td>
                            </tr>
                        </template>
                    </tbody>
                    <tbody x-show="importHistory.length === 0">
                        <tr>
                            <td colspan="7" style="text-align: center; color: var(--text-muted); padding: 2rem;">No update history</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

</main>
</body>
</html>
